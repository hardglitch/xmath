use std::error::Error;


enum SignalType {
    Plus,
    Multiple,
}
struct Signal {
    signal_type: SignalType,
    expr: usize,
    nst: usize,
}
struct Signals {
    list: Vec<Signal>,
}
impl Signals {
    fn new() -> Self {
        Signals{ list: Default::default() }
    }
    fn add(&mut self, s: Signal) {
        self.list.push(s);
    }
    fn del(&mut self) {
        self.list.pop();
    }
    fn is_captured(&self, snapshot: &Snapshot) -> bool {
        let last = self.list.last().unwrap();
        if last.expr != snapshot.expr || last.nst != snapshot.nst { return true };
        false
    }
    fn manager(&self, expr: &mut Expression) {
        let signal = self.list.last().unwrap();
        match signal.signal_type {
            SignalType::Plus => {
                let v1 = expr.expr.pop().unwrap();
                let v2 = expr.expr.pop().unwrap();

                // some actions

            },
            SignalType::Multiple => {},
        }
    }
}


struct Snapshot {
    expr: usize,
    nst: usize,
}
pub struct Expression<'a> {
    value: &'a str,
    expr: Vec<&'a str>,
    nst: usize,
}
impl<'a> Expression<'a> {
    pub fn new(value: &'a str) -> Self {
        Expression {
            value,
            expr: Vec::<&'a str>::new(),
            nst: 0,
        }
    }

    fn stack_snapshot(&self) -> Snapshot {
        let expr = self.expr.len();
        let nst = self.nst;
        Snapshot { expr, nst }
    }

    fn parse(&mut self) -> Result<(), Box<dyn Error>> {
        // ((x)+(1))^(2*ln(x))
        // x+1

        let mut signals = Signals::new();

        for (i, &ch) in self.value.as_bytes().iter().enumerate() {
            let ch_str = self.value.get(i..i+1).unwrap();

            let snapshot = self.stack_snapshot();
            if signals.is_captured(&snapshot) { signals.manager(self); }

            match ch {
                b'(' => self.nst += 1,
                b')' => self.nst -= 1,
                b'x' => self.expr.push(ch_str),
                b'+' => {
                    let snapshot = self.stack_snapshot();
                    let s = Signal{
                        signal_type: SignalType::Plus,
                        expr: snapshot.expr,
                        nst: snapshot.nst,
                    };
                    signals.add(s);
                },
                b' ' => continue,
                _ => { return  Err(format!("There is a problem with value in the {} position ('{}')", i, ch_str).into()) }
            }
        }
        Ok(())
    }

    pub fn print_result(&mut self) {
        match self.parse() {
            Ok(()) => println!("Result = {:?}", self.expr),
            Err(e) => println!("{:?}", e)
        }
    }
}
